(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{104:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=r.a.createContext({}),u=function(e){var t=r.a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return r.a.createElement(i.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,i=c(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,h=p["".concat(s,".").concat(d)]||p[d]||b[d]||o;return n?r.a.createElement(h,l(l({ref:t},i),{},{components:n})):r.a.createElement(h,l({ref:t},i))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var i=2;i<o;i++)s[i]=n[i];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},60:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return i}));var a=n(3),r=(n(0),n(104));const o={title:"MetalLB"},s={unversionedId:"setup/metallb",id:"setup/metallb",isDocsHomePage:!1,title:"MetalLB",description:"An Ingress Controller manages external access to a cluster",source:"@site/docs/setup/metallb.md",slug:"/setup/metallb",permalink:"/k8s-notes/setup/metallb",editUrl:"https://github.com/jasonk/k8s-notes/edit/master/docs/setup/metallb.md",version:"current",sidebar:"docs",previous:{title:"Jsonnet and Prometheus",permalink:"/k8s-notes/setup/jsonnet-and-prometheus"},next:{title:"Nginx Ingress",permalink:"/k8s-notes/setup/nginx-ingress"}},l=[],c={rightToc:l};function i({components:e,...t}){return Object(r.b)("wrapper",Object(a.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,"An ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/"}),"Ingress Controller")," manages external access to a cluster\nservice.  We've already seen how to use NodePort to expose services to\nthe rest of the network, but there are better options.  Instead of having\neach node just forward requests through to the appropriate pod, what\nif we had an actual load balancer handling that?"),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://metallb.universe.tf/"}),"MetalLB")," is a load balancing controller\nfor bare-metal installations where you don't have a cloud-native load\nbalancer to work with (such as AWS's ELB)."),Object(r.b)("h1",{id:"preparing-kube-proxy"},"Preparing kube-proxy"),Object(r.b)("p",null,"Before we can install MetalLB we need to make sure our ",Object(r.b)("inlineCode",{parentName:"p"},"kube-proxy"),"\ninstall has the required configuration, with strict ARP enabled and\nrunning in IPVS mode."),Object(r.b)("p",null,"I'm going to show you a couple of different ways you can handle making\nthis configuration change, to give you some ideas about ways you can\nconfigure your cluster when you need to, you don't need to do all of\nthem though."),Object(r.b)("p",null,"First lets just check whether we already have the right settings or\nnot, by retrieving the kube-proxy ConfigMap and searching for the\nsettings we need."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl get configmap kube-proxy -n kube-system -o yaml \\\n  | grep -E '(mode|strictARP)'\n")),Object(r.b)("p",null,"That will return something like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'strictARP: false\nmode: ""\n')),Object(r.b)("p",null,"Looks like we don't have the right settings here.  One way we could\nfix that is by using ",Object(r.b)("inlineCode",{parentName:"p"},"kubectl edit configmap kube-proxy -n\nkube-system")," to open the ConfigMap in a text editor.  When you save\nthe file and exit the editor the changes will get applied to the\ncluster."),Object(r.b)("p",null,"Another common way of handling it is to retrieve the configmap, pipe\nit through something like ",Object(r.b)("inlineCode",{parentName:"p"},"sed")," to make the changes, then pipe it back\ninto ",Object(r.b)("inlineCode",{parentName:"p"},"kubectl apply"),".  One useful feature of kubectl is that you can\nuse ",Object(r.b)("inlineCode",{parentName:"p"},"diff")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"apply")," to just see what changes would be made\nwithout actually making them, then if the changes look good you can\nswitch back to apply to actually deploy them."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),'kubectl get configmap kube-proxy -n kube-system -o yaml \\\n  | sed -e "s/strictARP: false/strictARP: true/" -e \'s/mode: ""/mode: ipvs/\' \\\n  | kubectl diff -f- -n kube-system\n')),Object(r.b)("p",null,"If all looks good then change ",Object(r.b)("inlineCode",{parentName:"p"},"kubectl diff")," to ",Object(r.b)("inlineCode",{parentName:"p"},"kubectl apply")," and\napply the configuration."),Object(r.b)("p",null,"Since we've changed the kube-proxy configuration, we need to kill off\nall the existing kube-proxy pods so that new ones will be built with\nthe new configuration."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl get pods -n kube-system | awk '{print $1}' | grep kube-proxy \\\n  | xargs -n1 kubectl delete pod -n kube-system\n")),Object(r.b)("h1",{id:"installing-metallb"},"Installing MetalLB"),Object(r.b)("p",null,'Installing the MetalLB manifests will setup both it\'s controller (a\ncluster-wide controller that handles IP address assignments) and\nalso a daemonset named "speaker" that is the component that speaks the\nprotocols of your choice to make services accessible.  This also\ncreates the necessary service accounts and RBAC permissions.'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.5/manifests/namespace.yaml\nkubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.5/manifests/metallb.yaml\n")),Object(r.b)("p",null,"You also need to create a secret that will be used to encrypt\ncommunication between the speakers that they use for fast dead node\ndetection."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),'kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey="$(openssl rand -base64 128)"\n')),Object(r.b)("p",null,"We're going to configure MetalLB to use Layer 2 mode, because it's the\nsimplest, and it's all we need for Nginx Ingress.  All that we really\nneed to configure it is to provide a range of IP addresses that it can\nuse for creating load balancers.  These addresses don't even need to\nbe bound to the network interfaces of your worker nodes, MetalLB will\nrespond to ARP requests on the local network directly, so you can just\npick a block of IPs from your local network that aren't currently in\nuse by anything else (although you also need to ensure that your\nrouter or DHCP server won't try to assign these to any other systems)."),Object(r.b)("p",null,"To set this up we're going to apply a ",Object(r.b)("inlineCode",{parentName:"p"},"ConfigMap")," into the namespace.\nI'm going to use ",Object(r.b)("inlineCode",{parentName:"p"},"192.168.1.240-192.168.1.249")," as the LB IP's:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl apply -f- <<'END'\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  namespace: metallb-system\n  name: config\ndata:\n  config: |\n    address-pools:\n    - name: default\n      protocol: layer2\n      addresses:\n      - 192.168.1.240-192.168.1.249\nEND\n")),Object(r.b)("h1",{id:"configuring-loadbalancer-services"},"Configuring LoadBalancer Services"),Object(r.b)("p",null,"Now that we have MetalLB configured, let's add a LoadBalancer for our\nGrafana application.  To do that we'll just edit the service configuration\nand change the type from ",Object(r.b)("inlineCode",{parentName:"p"},"NodePort")," to ",Object(r.b)("inlineCode",{parentName:"p"},"LoadBalancer"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl edit service/grafana -n monitoring\n")),Object(r.b)("p",null,"Once that is done you can describe it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"kubectl describe services grafana -n monitoring\n")),Object(r.b)("p",null,"Which will produce some output that includes something like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"LoadBalancer Ingress:     192.168.1.240\nPort:                     http  3000/TCP\n")),Object(r.b)("p",null,"Which means you should be able to open a browser to\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://192.168.1.240:3000/"}),"http://192.168.1.240:3000/")," and see the Grafana login screen."))}i.isMDXComponent=!0}}]);