(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{61:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return h}));var r=n(3),o=n(7),a=(n(0),n(89)),i={title:"Control Plane"},c={unversionedId:"concepts/control-plane",id:"concepts/control-plane",isDocsHomePage:!1,title:"Control Plane",description:"The thing that is making all of this work is the control plane,",source:"@site/docs/concepts/control-plane.md",slug:"/concepts/control-plane",permalink:"/k8s-notes/concepts/control-plane",editUrl:"https://github.com/jasonk/k8s-notes/edit/main/docs/concepts/control-plane.md",version:"current",sidebar:"docs",previous:{title:"Exploring Pods",permalink:"/k8s-notes/setup/exploring-pods"},next:{title:"Operators",permalink:"/k8s-notes/concepts/operators"}},s=[{value:"Master Node",id:"master-node",children:[]},{value:"Worker Node",id:"worker-node",children:[]},{value:"API server",id:"api-server",children:[]},{value:"etcd",id:"etcd",children:[]},{value:"scheduler",id:"scheduler",children:[]},{value:"controller-manager",id:"controller-manager",children:[]},{value:"kubelet",id:"kubelet",children:[]},{value:"kube-proxy",id:"kube-proxy",children:[]}],l={rightToc:s};function h(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The thing that is making all of this work is the ",Object(a.b)("inlineCode",{parentName:"p"},"control plane"),",\nwhich manages how workloads are executed, monitored, and maintained in\nthe cluster."),Object(a.b)("h1",{id:"machine-classes"},"Machine Classes"),Object(a.b)("p",null,"In any cluster there are two classes of machines:"),Object(a.b)("h2",{id:"master-node"},"Master Node"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"master node")," contains most of the components which make up the\ncontrol plane.  In a moderately sized cluster it's not uncommon to\nhave a single master node, though you can have multiple masters for\nhigh availability."),Object(a.b)("h2",{id:"worker-node"},"Worker Node"),Object(a.b)("p",null,"A ",Object(a.b)("inlineCode",{parentName:"p"},"worker node")," is a machine that is actually doing the work of\nrunning application workloads.  You might have different machine types\ntailored to different types of workloads in a cluster.  For example,\nyou may have some nodes with heavy-duty GPUs and some that are\nCPU-optimized."),Object(a.b)("h1",{id:"control-plane-components"},"Control Plane Components"),Object(a.b)("h2",{id:"api-server"},"API server"),Object(a.b)("p",null,"When you communicate with the cluster, you do it through the ",Object(a.b)("inlineCode",{parentName:"p"},"API\nserver"),".  The API server validates requests to update objects and acts\nas the unified interface for queries about the cluster's current\nstate."),Object(a.b)("h2",{id:"etcd"},"etcd"),Object(a.b)("p",null,"The state of the cluster is stored in etcd.  This is the only stateful\ncomponent of the control plane.  It stores information about the\ncluster configuration, object specifications, object statuses, cluster\nnodes, and the assignments of objects to nodes."),Object(a.b)("h2",{id:"scheduler"},"scheduler"),Object(a.b)("p",null,"The scheduler is in charge of deciding what whould run where.  The\nscheduler will ask the API server which objects haven't been assigned\nto a node, and then it will use the configuration of those objects and\nthe state of the cluster to determine which nodes to run them on.  It\nthen communicates this back to the API server to be recorded in etcd."),Object(a.b)("h2",{id:"controller-manager"},"controller-manager"),Object(a.b)("p",null,"At a high level the controller-manager is repsonsible for managing the\nstate of the cluster.  It manages a collection of controllers, which\nare each responsible for monitoring a specific resource type.  These\ncontrollers monitor the state of those components and validate that\nthe current state conforms to the desired state that is stored in\netcd.  The controllers are reponsible for making sure the pods stay\nhealthy."),Object(a.b)("h2",{id:"kubelet"},"kubelet"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"kubelet")," is is a small piece of the control plane that runs on\neach worker node.  It is responsible for informing the API server\nabout the existing of the node, and it's available resources so that\nthe scheduler can assign pods to it.  When pods are scheduled the API\nserver will inform the kubelet, which will then start up the pods."),Object(a.b)("h2",{id:"kube-proxy"},"kube-proxy"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"kube-proxy")," also runs on each worker node.  It is responsible for\nall of the networking related concerns, like how to forward traffic to\nthe appropriate pod."),Object(a.b)("h1",{id:"control-plane-architecture"},"Control Plane Architecture"),Object(a.b)("p",null,"The whole system is architected to ensure that component failures have\nminimal impact.  For example, even if the master node goes down, none\nof the running applications would be immediately affected, losing the\ncontrol plane just prevents you from making any further changes to the\ncluster until a new master node is brought online.  If any worker node\nfails, the control plane will ensure that all of the pods it was\nrunning are started up somewhere else."))}h.isMDXComponent=!0},89:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),h=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=h(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=h(n),p=r,b=u["".concat(i,".").concat(p)]||u[p]||d[p]||a;return n?o.a.createElement(b,c(c({ref:t},l),{},{components:n})):o.a.createElement(b,c({ref:t},l))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var l=2;l<a;l++)i[l]=n[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);